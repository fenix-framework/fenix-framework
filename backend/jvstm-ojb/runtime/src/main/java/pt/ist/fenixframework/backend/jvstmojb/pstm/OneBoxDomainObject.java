package pt.ist.fenixframework.backend.jvstmojb.pstm;

import java.io.Serializable;

import org.apache.commons.lang.StringUtils;

import jvstm.Transaction;
import jvstm.util.Cons;
import jvstm.util.Pair;
import pt.ist.fenixframework.backend.jvstmojb.pstm.OneBoxDomainObject;
import pt.ist.fenixframework.backend.jvstmojb.repository.ToSqlConverter;
import pt.ist.fenixframework.core.DomainObjectAllocator;
import pt.ist.fenixframework.dml.runtime.Relation;

/**
 * The OneBoxDomainObject class is meant to be used as a superclass of
 * DomainObjects generated by the DML compiler that use a single box
 * (defined in this class) to hold the entire state of a DomainObject.
 * 
 * This will reduce the amount of memory needed to store each object
 * (because there are less overheads caused by the vboxes), at the
 * potential cost of increasing the likelihood of conflicts, because
 * now the conflict detection granularity is at the object level,
 * rather than at the slot level.
 * 
 * This class uses also a lazy approach to the materialization of
 * RelationLists for holding the set of objects that relate to an
 * object, so that unused RelationLists don't consume memory
 * unnecessary.
 */

public abstract class OneBoxDomainObject extends AbstractDomainObject {

    // box holding the entire state of the object
    private final VState obj$state;
    private static final String OBJ_STATE_SLOT_NAME = "obj$state";

    // we need to know whether this instance of the object was created
    // to materialize an already existing object that is being read
    // from the persistent store or if it is a new object
    private final boolean isNewObject;

    // Collection of RelationLists that are created lazilly
    private volatile Cons<Pair<String, RelationList>> relationLists = Cons.empty();

    // This is the constructor used when a new DomainObject is created
    protected OneBoxDomainObject() {
        super();
        this.obj$state = VState.makeNew(this, OBJ_STATE_SLOT_NAME, false);
        this.obj$state.put(this, OBJ_STATE_SLOT_NAME, make$newState());
        this.isNewObject = true;
        create$allLists();
    }

    // This is the constructor used as part of the allocate-instance
    // protocol, when a DomainObject is being read from the persistent
    // store
    protected OneBoxDomainObject(DomainObjectAllocator.OID oid) {
        super(oid);
        this.obj$state = VState.makeNew(this, OBJ_STATE_SLOT_NAME, true);
        this.isNewObject = false;
    }

    // each class will have to implement/override this method to
    // create an instance of the appropriate subclass of DO_State
    protected abstract DO_State make$newState();

    // each class will have to override this method to create all of
    // the lists corresponding to relations when a new instance is
    // created
    protected void create$allLists() {
    }

    protected final DO_State get$obj$state(boolean forWriting) {
        DO_State currState = (DO_State) this.obj$state.get(this, OBJ_STATE_SLOT_NAME);
        if (forWriting) {
            if (currState.committed) {
                DO_State newState = make$newState();
                currState.copyTo(newState);
                this.obj$state.put(this, OBJ_STATE_SLOT_NAME, newState);
                return newState;
            } else {
                /*
                 * This workaround is needed to keep FenixConsistencyCheckTransactions from performing writes
                 * to DOStates which have already been written to by the parent transaction.
                 * This workaround is specific for the FenixConsistencyCheckTransaction, because it is the only
                 * current case of a read-only nested transaction.
                 */
                if (TransactionSupport.currentFenixTransaction() instanceof FenixConsistencyCheckTransaction) {
                    throw new Error("It is not permitted to perform writes inside a Consistency Predicate");
                }
            }
        }
        return currState;
    }

    @Override
    protected void readSlotsFromResultSet(java.sql.ResultSet rs, int txNumber) throws java.sql.SQLException {
        throw new Error("readSlotsFromResultSet should not be used for OneBoxDomainObjects");
    }

    @Override
    public final void readFromResultSet(java.sql.ResultSet rs) throws java.sql.SQLException {
        int txNumber = Transaction.current().getNumber();
        DO_State loadedState = make$newState();

        readStateFromResultSet(rs, loadedState);
        // this state was already committed and is being read now
        loadedState.markCommitted();

        obj$state.persistentLoad(loadedState, txNumber);

        readMetaObjectFromResultSet(rs, txNumber);
    }

    protected abstract void readStateFromResultSet(java.sql.ResultSet rs, DO_State state) throws java.sql.SQLException;

    protected static class DO_State {
        private boolean committed = false;

        void markCommitted() {
            this.committed = true;
        }

        // qubIT Comment: Added to DO state the creationEntity/updateEntity fields
        //
        //
        private java.lang.String creationEntity;
        private org.joda.time.DateTime creationEntityDate;
        private UpdateEntity updateEntity;
        private UpdateTimestamp updateEntityDate;

        protected void copyTo(DO_State newState) {
            DO_State newCasted = (DO_State) newState;
            newCasted.creationEntity = this.creationEntity;
            newCasted.creationEntityDate = this.creationEntityDate;
            newCasted.updateEntity = this.updateEntity;
            newCasted.updateEntityDate = this.updateEntityDate;

        }

        // serialization code
        protected Object writeReplace() throws java.io.ObjectStreamException {
            return new SerializedForm(this);
        }

        // TODO latest FF does not have serialization form is it really needed?
        protected static class SerializedForm implements Serializable {
            private static final long serialVersionUID = 1L;

            private final java.lang.String creationEntity;
            private final org.joda.time.DateTime creationEntityDate;
            private final pt.ist.fenixframework.backend.jvstmojb.pstm.ValueTypeSerializationGenerator.Serialized$UpdateEntity updateEntity;
            private final pt.ist.fenixframework.backend.jvstmojb.pstm.ValueTypeSerializationGenerator.Serialized$UpdateTimestamp updateEntityDate;

            protected SerializedForm(DO_State obj) {
                super();
                this.creationEntity = obj.creationEntity;
                this.creationEntityDate = obj.creationEntityDate;
                this.updateEntity =
                        pt.ist.fenixframework.backend.jvstmojb.pstm.ValueTypeSerializationGenerator
                                .serialize$UpdateEntity(obj.updateEntity);
                this.updateEntityDate = ValueTypeSerializationGenerator.serialize$UpdateTimestamp(obj.updateEntityDate);

            }

            Object readResolve() throws java.io.ObjectStreamException {
                DO_State newState = new DO_State();
                fillInState(newState);
                return newState;
            }

            protected void fillInState(OneBoxDomainObject.DO_State obj) {
                DO_State state = (DO_State) obj;
                state.creationEntity = this.creationEntity;
                state.creationEntityDate = this.creationEntityDate;
                state.updateEntity = ValueTypeSerializationGenerator.deSerialize$UpdateEntity(this.updateEntity);
                state.updateEntityDate = ValueTypeSerializationGenerator.deSerialize$UpdateTimestamp(this.updateEntityDate);
            }

        }

    }

    @Override
    VersionedSubject getSlotNamed(String attrName) {
        if (attrName.equals(OBJ_STATE_SLOT_NAME)) {
            return obj$state;
        }

        Relation rel = get$$relationFor(attrName);
        if (rel != null) {
            return get$$relationList(attrName, rel);
        } else {
            return super.getSlotNamed(attrName);
        }
    }

    // In the following, we have the methods that handle the lazy creation of the RelationLists

    protected RelationList get$$relationList(String attrName, Relation relation) {
        Cons<Pair<String, RelationList>> allLists = relationLists;
        RelationList list = findRelationList(allLists, Cons.empty(), attrName);
        if (list != null) {
            return list;
        }

        // if we haven't found the list, then we need to create it first
        // but we need to ensure that no one is racing to do the same
        synchronized (this) {
            // read the list of relationLists again to see if someone
            // may have changed it in the meanwhile
            Cons<Pair<String, RelationList>> currentLists = relationLists;

            if (currentLists != allLists) {
                // we need to see again if a new list was created
                list = findRelationList(currentLists, allLists, attrName);
                if (list != null) {
                    return list;
                }
            }

            // we really need to create the list
            RelationList newList = new RelationList(this, relation, attrName, (!isNewObject));
            relationLists = currentLists.cons(new Pair<String, RelationList>(attrName, newList));
            return newList;
        }
    }

    private static RelationList findRelationList(Cons<Pair<String, RelationList>> allLists, Object lastList, String attrName) {
        while (allLists != lastList) {
            Pair<String, RelationList> list = allLists.first();
            // it is not safe to use == instead of equals(Object) to
            // compare Strings here because this method may be
            // called with non-interned strings (when reading the changelogs from DB)
            if (list.first.equals(attrName)) {
                return list.second;
            }
            allLists = allLists.rest();
        }

        return null;
    }

    protected Relation get$$relationFor(String attrName) {
        return null;
    }

    public final boolean is$$do$$Valid() {
        try {
            return get$obj$state(false) != null;
        } catch (VersionNotAvailableException | ClassCastException t) {
            return false;
        }
    }

    @Override
    protected void deleteDomainObject() {
        super.deleteDomainObject();
        // Mark the VState as deleted
        obj$state.markAsDeleted();

        // Ensure that all RelationLists exist...
        create$allLists();

        Cons<Pair<String, RelationList>> lists = relationLists;
        while (lists != (Object) Cons.empty()) {
            // ... and mark them as deleted
            lists.first().second.markAsDeleted();
            lists = lists.rest();
        }
    }

    // Adding functionality for CreationEntity and UpdateEntity
    public java.lang.String getCreationEntity() {
        return this.get$obj$state(false).creationEntity;
    }

    public String getCreatorUsername() {
        String result = null;

        final String creationEntity = getCreationEntity();
        if (StringUtils.isNotBlank(creationEntity)) {
            String[] split = creationEntity.split(":");
            if (split.length == 2) {
                result = split[1];
            } else {
                result = creationEntity;
            }
        }

        return result;
    }

    public String getUpdatorUsername() {
        String result = null;

        final UpdateEntity updateEntity = getUpdateEntity();
        if (updateEntity != null) {
            result = getUpdateEntity().getUsername();
        }

        return result;
    }

    public String getUpdatorServiceName() {
        String result = null;

        final UpdateEntity updateEntity = getUpdateEntity();
        if (updateEntity != null) {
            result = getUpdateEntity().getServiceName();
        }

        return result;
    }

    public void setCreationEntity(java.lang.String creationEntity) {
        this.get$obj$state(true).creationEntity = creationEntity;
    }

    private java.lang.String get$creationEntity() {
        java.lang.String value = this.get$obj$state(false).creationEntity;
        return (value == null) ? null : ToSqlConverter.getValueForString(value);
    }

    private final void set$creationEntity(java.lang.String arg0, OneBoxDomainObject.DO_State obj$state) {
        ((DO_State) obj$state).creationEntity = ((arg0 == null) ? null : arg0);
    }

    public org.joda.time.DateTime getCreationEntityDate() {
        return this.get$obj$state(false).creationEntityDate;
    }

    public void setCreationEntityDate(org.joda.time.DateTime creationEntityDate) {
        this.get$obj$state(true).creationEntityDate = creationEntityDate;
    }

    private java.sql.Timestamp get$creationEntityDate() {
        org.joda.time.DateTime value = this.get$obj$state(false).creationEntityDate;
        return (value == null) ? null : ToSqlConverter.getValueForDateTime(value);
    }

    private final void set$creationEntityDate(org.joda.time.DateTime arg0, OneBoxDomainObject.DO_State obj$state) {
        ((DO_State) obj$state).creationEntityDate = ((arg0 == null) ? null : arg0);
    }

    public UpdateEntity getUpdateEntity() {
        return this.get$obj$state(false).updateEntity;
    }

    public void setUpdateEntity(UpdateEntity updateEntity) {
        this.get$obj$state(true).updateEntity = updateEntity;
    }

    private java.lang.String get$updateEntity() {
        UpdateEntity value = this.get$obj$state(false).updateEntity;
        return (value == null) ? null : ToSqlConverter.getValueForString(value.externalize());
    }

    private final void set$updateEntity(java.lang.String arg0, OneBoxDomainObject.DO_State obj$state) {
        ((DO_State) obj$state).updateEntity = ((arg0 == null) ? null : new UpdateEntity(arg0));
    }

    public UpdateTimestamp getUpdateEntityDate() {
        return this.get$obj$state(false).updateEntityDate;
    }

    public void setUpdateEntityDate(UpdateTimestamp updateEntityDate) {
        this.get$obj$state(true).updateEntityDate = updateEntityDate;
    }

    private java.sql.Timestamp get$updateEntityDate() {
        UpdateTimestamp value = this.get$obj$state(false).updateEntityDate;
        return (value == null) ? null : ToSqlConverter.getValueForDateTime(value.externalize());
    }

    private final void set$updateEntityDate(org.joda.time.DateTime arg0, OneBoxDomainObject.DO_State obj$state) {
        ((DO_State) obj$state).updateEntityDate = ((arg0 == null) ? null : new UpdateTimestamp(arg0));
    }

    // qubIT comment: base get$auditInfo() method, the generator should then generate
    // a get$auditInfo() method in each baseClass with the associated information
    //
    public java.util.Map<String, Object> get$auditInfo() {
        java.util.Map<String, Object> map = new java.util.HashMap<String, Object>();
        Object creationEntity = this.get$obj$state(false).creationEntity;
        if (creationEntity != null) {
            map.put("creationEntity", creationEntity);
        }
        Object creationEntityDate = this.get$obj$state(false).creationEntityDate;
        if (creationEntityDate != null) {
            map.put("creationEntityDate", creationEntityDate);
        }
        Object updateEntity = this.get$obj$state(false).updateEntity;
        if (updateEntity != null) {
            map.put("updateEntity", updateEntity);
        }
        Object updateEntityDate = this.get$obj$state(false).updateEntityDate;
        if (updateEntityDate != null) {
            map.put("updateEntityDate", updateEntityDate);
        }
        return map;
    }
}
